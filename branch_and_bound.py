# -*- coding: utf-8 -*-
"""Branch_and_bound.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/MateusFreitas-C/Branch_and_Bound/blob/main/Branch_and_bound.ipynb
"""

from mip import *
import math as mt

# Função para ler os dados das instancias

def load_data_inst(file_path):
  with open(file_path, 'r') as file:
    first_line = file.readline().strip()
    vars_qty, constr_qty = map(int, first_line.split())

    second_line = file.readline().strip()
    k = list(map(float, second_line.split()))

    c = []
    for _ in range(constr_qty):
        line = file.readline().strip()
        c.append(list(map(float, line.split())))

    return vars_qty, constr_qty, k, c

def save(model, filename):
  model.write(filename)
  with open(filename, 'r') as file:
      return file.read()

stack = []

def branch_and_bound(model, x, fp):
    global zp, zd
    global iter

    # Criando cópias do modelo para o ramo inferior e superior
    model_lower = model.copy()
    model_upper = model.copy()

    # Otimiza o modelo atual
    status = model.optimize()

    fp.write("--" * 70 + "\n")
    fp.write(f"Iteração {iter}\n" +
           (f"Resultado da Relaxação Linear: {model.objective_value:.3f}\n" if status != OptimizationStatus.INFEASIBLE else "\n"))

    # Adiciona o índice atual à pilha de iterações e incrementa iterador
    stack.insert(0, iter)
    iter += 1

    # Verificação de poda por inviabilidade
    if status in (OptimizationStatus.INFEASIBLE, OptimizationStatus.NO_SOLUTION_FOUND):
        return None, False

    # Atualiza o limite dual (zd) se o valor do objetivo atual for menor
    zd = min(zd, model.objective_value)

    fp.write("Variáveis: \n")
    for v in model.vars:
      fp.write(f"{v.name} = {v.x:.2f}\n")

    # Inicialização de variáveis para verificar se há solução fracionária
    best_var = None
    found_fractional = False
    closest_to_half = 0.5  # Define uma base inicial para verificar quão próxima uma variável está de 0.5

    # Itera sobre as variáveis do modelo para encontrar a mais próxima de 0.5
    for v in model.vars:
        if 0 < v.x < 1:  # Verifica se a variável é fracionária
            dist_to_half = abs(v.x - 0.5)
            if dist_to_half < closest_to_half:
                closest_to_half = dist_to_half
                best_var = v
                found_fractional = True

    # Se não houver variáveis fracionárias, a solução é inteira, podemos retornar o modelo
    if not found_fractional:
        return model, True

    fp.write(f"Variável escolhida: {best_var} = {best_var.x:.2f}\n")

    # Poda por limitante (verifica se a solução atual é pior que a melhor já encontrada)
    if zp >= model.objective_value:
        return model, False

    fp.write(f"\nRestrições:")
    constraints = save(model, "model.lp")
    fp.write(f"\n\n{constraints}\n")

    # Ramo esquerdo: adiciona a restrição de que a melhor variável fracionária seja 0
    model_lower += best_var == 0
    left_result, is_integral = branch_and_bound(model_lower, x, fp)

    # Remove a iteração da pilha após a chamada recursiva
    stack.pop(0)
    if is_integral and (zp == -mt.inf or left_result.objective_value > zp):
        zp = left_result.objective_value

    # Ramo direito: adiciona a restrição de que a melhor variável fracionária seja 1
    model_upper += best_var == 1
    right_result, is_integral = branch_and_bound(model_upper, x, fp)

    # Remove a iteração da pilha após a chamada recursiva
    stack.pop(0)
    if is_integral and (zp == -mt.inf or right_result.objective_value > zp):
        zp = right_result.objective_value

    # Retorna o melhor resultado encontrado ou o modelo atual se nenhum foi encontrado
    return left_result if left_result is not None else model, False

def run_tests():
  for i in range(4):
    global zp, zd
    global iter

    zp, zd = -mt.inf, -mt.inf
    iter = 1

    vars_qty, constr_qty, k, c = load_data_inst(f"instancias/teste{i+1}.txt")

    model = Model(sense=MAXIMIZE, solver_name=CBC)

    x = [model.add_var(var_type=CONTINUOUS, name=f"x_{j}", lb=0, ub=1) for j in range(vars_qty)]
    model.objective = xsum(k[j] * x[j] for j in range(vars_qty))

    for n in range(constr_qty):
        model += xsum(c[n][j] * x[j] for j in range(vars_qty)) <= c[n][len(c[n]) - 1]

    fres = open(f"resposta{i+1}.txt", "w")

    branch_and_bound(model, x, fres)

    print(f"Solution Value {i+1}: {zp}")
    fres.write(f"Solution Value {i+1}: {zp}")

    fres.close()

run_tests()

fres = open(f"resposta1.txt", "r")
print(fres.read())
fres.close()

fres = open(f"resposta2.txt", "r")
print(fres.read())
fres.close()

fres = open(f"resposta3.txt", "r")
print(fres.read())
fres.close()

fres = open(f"resposta4.txt", "r")
print(fres.read())
fres.close()